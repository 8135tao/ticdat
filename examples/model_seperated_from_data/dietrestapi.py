import opalytils.pjcutils as pjc
import opalytils.sqliteutils as sql
import opalytils.sqlticdat as ticdat
import os
import inspect
from dietmodel import dataFactory, solutionFactory
import dietmodel as dm
import shutil

def _codeFile() :
    return  os.path.realpath(os.path.abspath(inspect.getsourcefile(_codeFile)))
__codeFile = _codeFile()
def _codeDir():
    return os.path.dirname(__codeFile)

def schemaDir() :
    return os.path.join(_codeDir(), "diet_schema")

#sql.SQLDbDeveloperHelper.removeAutoGenerated(schemaDir())

_sqlDb = sql.SQLDb(schemaDir())
_developHelper= sql.SQLDbDeveloperHelper(_sqlDb)

assert _developHelper.good() or (pjc.memo(_developHelper) and not _developHelper)
# ######### uncomment this section as part of development process.
# _developHelper.makeParameterBadViews(miscKeys=('lpFileName', 'dbFileName'))
# _developHelper.dumpSuggestionsToDir(os.path.join(schemaDir(), "inp", "views"))
# ###### when uncommenting the above don't run unit tests. just import this module from ipython

_jsonSql =sql.JsonReadyWrapper(_sqlDb)
_solverLoadPath = lambda : pjc.pjcEasterEggSolverLoadPath("diet")


_areThingsWeird = False
_exceptionDecorator = sql.jsonReadyExceptions
if _areThingsWeird :
    pjc.debugBreak() # THINGS ARE WEIRD!!!
    _exceptionDecorator = lambda x : x


# ---------------------- BEGIN REST READY API DEFINITION ------------------------------
validatorSchema = _exceptionDecorator(_jsonSql.validatorSchema)

getSchema = _exceptionDecorator(_jsonSql.getSchema)

upload = _exceptionDecorator(sql.uploadFactory(_jsonSql, _solverLoadPath()))

uploadedResults = _exceptionDecorator(sql.uploadedResultsFactory())

solve = _exceptionDecorator(sql.solverFactory("diet.0.13", _codeDir(),
        lambda          outputTxt, errorTxt, netKey, conExitController, progressFunction:
                _solve( outputTxt, errorTxt, netKey, conExitController, progressFunction),
        solveExtraDoc=
                    """
                        "solution"  : a dictionary that describes the solution for the model (if one is generated).
                                      contains table data in "fields","rows" format
                    """))

solvedResults = _exceptionDecorator(sql.solvedResultsFactory())

TROUBLE_SHOOT = _exceptionDecorator(sql.solverTROUBLE_SHOOT_Factory(_jsonSql))
# ---------------------- END REST READY API DEFINITION ------------------------------

import sys
_module = sys.modules[_codeDir.__module__]
restReadyRoutines= tuple(x for x in dir(_module) if callable(getattr(_module, x)) and not x.startswith("_"))

creator = sql.CreatorWrapper(_sqlDb, _module, "diet.db")

_ticDatInp = ticdat.SqlDataCreator(_sqlDb, goodToInp=True)
_ticDatSln = ticdat.SqlDataCreator(_sqlDb, goodToInp=False, alternatePrepend="sln")

def _superDictEqual(d1, d2) :
    return all((k in d1) and (d1[k] == d2[k]) for k in d2)

assert _superDictEqual(_ticDatInp.ticDatFactory.primary_key_fields, dataFactory.primary_key_fields)
assert _superDictEqual(_ticDatInp.ticDatFactory.data_fields, dataFactory.data_fields)
assert _superDictEqual(_ticDatSln.ticDatFactory.primary_key_fields, solutionFactory.primary_key_fields)
assert _ticDatSln.ticDatFactory.data_fields == solutionFactory.data_fields

class DietData(_ticDatInp.TicDat, ticdat.WriteToCon) :
    def __init__(self, dbFile = None):
        super(DietData, self).__init__()
        self._readFromDbFile(dbFile) if dbFile else None
        self._freeze() if dbFile else None

class DietSolution(_ticDatSln.TicDat, ticdat.WriteToCon):
    pass

_formatIt = lambda x : "{:.2f}".format(x) if pjc.numeric(x) else str(x)
def _solve(outputTxt, errorTxt, netKey, conExitController, progressFunction) :

  progressFunction = progressFunction or (lambda x : True)
  headlineError = lambda _str : progressFunction({"error":_str})

  if not os.path.isdir(netKey) :
    errorTxt.write("Invalid netKey argument:%s\n"%netKey)
    raise Exception("Invalid netKey argument:%s\n"%netKey)

  loadedPath = os.path.join(netKey, "loaded.db")
  if not os.path.exists(loadedPath) :
    errorTxt.write("netKey failed to resolve:%s\n"%netKey)
    raise Exception("netKey failed to resolve:%s\n"%netKey)

  bothWrite = lambda x :(outputTxt.write(x), errorTxt.write(x))
  copyLoadedPathIfNeeded=lambda : None
  dat = DietData(loadedPath)
  with pjc.EnterExitCaller(exitHandler=lambda : copyLoadedPathIfNeeded()) :
   with  (sql.sqlConnect(loadedPath) ) as con :
    with conExitController(con):
        origSolveParams = sql.DictTableObject("goodParameters", hasTicId=True).readDict(con)

        resultsDir = os.path.dirname(outputTxt.path)
        assert os.path.dirname(errorTxt.path) == resultsDir, "seems weird to use dif paths here"
        copyLoadedPathIfNeeded = lambda : shutil.copyfile(loadedPath,
                    os.path.join(resultsDir, origSolveParams["dbFileName"])) \
                    if "dbFileName" in origSolveParams else None

        rtn = pjc.FixedKeyDict(files =  # will return a list of all the generated files
            ({origSolveParams["dbFileName"]} if "dbFileName" in origSolveParams else set()).union(
                                 {os.path.basename(x.path) for x in (outputTxt, errorTxt)}),
                         solution = {}) # the sln tables

        solution = dm.solve(dat)

        if solution :
           outputTxt.write("Total Cost: %s\n"%_formatIt(solution.parameters[0]["totalCost"]))
           dietSolution = DietSolution(parameters = solution.parameters,
                                       buyFood = solution.buyFood,
                                       consumeNutrition = solution.consumeNutrition)
           dietSolution.writeToCon(con)
           rtn["solution"] = _sqlDb.dumpsToDict(con, lambda t : not t.startswith("sln"))
        else :
            bothWrite("Unable to find solution\n")

        return rtn
